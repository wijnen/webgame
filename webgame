#!/usr/bin/python3
# Webgame main executable.

'''
This file is part of the webgame system.
It uses the game file (which has the gpy extension) to set up a game.
The game file is imported as a module, so when it's running it needs to have
the py extension.
Some parts of this file can be called from the game file.
This file is used by the webgame-build script.
'''

'''Translation notes {{{
The system uses gettext for translations. The server itself only writes
debugging messages to the console, which are are not translated.

All translatable strings are marked with _(), which is a no-op in the Python
code. Translating happens in javascript.
}}}'''

# Imports and config. {{{
import gettext
import traceback
import network
import websocketd
import fhs
import sys
import os
import time
import json
import re
import collections
import importlib
fhs.option('port', 'network port to listen for client connections on', default = '8891')
fhs.option('tls', 'use encrypted connection', argtype = bool)
fhs.option('keep', 'keep a game running when the last player quits', argtype = bool)
fhs.option('forbidden-exts', 'never load files with these extentions (comma-separated list)', default = '.blend,.blend1,~')
fhs.init(help = 'Webgame framework', version = '0.3', contact = 'Bas Wijnen <wijnen@debian.org>', game = True)
# }}}

# custom log function with modified file name
def log(*msg):
	websocketd.log(*msg, filename = 'webgame', depth = 1)

class Transaction:	# Singleton class {{{
	def __init__(self):
		self.instance = None
		self.phase = 'idle'
		self.name = None
		self.args = None
	def enter(self, instance):
		assert self.instance is None
		assert self.args is None
		assert self.phase == 'idle'
		self.phase = 'ready'
		self.instance = instance
	def __enter__(self):
		assert self.instance is not None
		assert self.phase in ('ready', 'calling', 'called')
		self.phase = 'busy'
		self.instance.game.broadcast.webgame('start')
	def __exit__(self, *exc):
		assert self.instance is not None
		assert self.phase == 'busy'
		self.phase = 'ready'
		self.instance.game.broadcast.webgame('finish', self.name, self.args)
		self.name = None
		self.args = None
	def leave(self, instance):
		assert self.instance is instance
		assert self.phase == 'ready'
		self.phase = 'idle'
		self.instance = None
	def __call__(self, *args):
		assert self.instance is not None
		assert self.phase == 'calling'
		assert self.args is None
		self.phase = 'called'
		self.args = args
		return self
	def __getattr__(self, attr):
		assert self.instance is not None
		assert self.phase == 'ready'
		assert self.name is None
		self.name = attr
		self.phase = 'calling'
		return self

transaction = Transaction()
# }}}

# Global variables. {{{
# All connections (both viewers and players); keys are names.
connections = {}

# Generator type, for checking if things are generators.
generator_type = type((lambda: (yield))())

# All currently running games.
instances = {}

# Title game instance.
title_game = None

# Commands that work always.
cmds = {}

# Number of players; this is created from games[].num_players.
# Keys are the same as the keys in games.
# Every value is a function which accepts a requested number of players as argument and returns a resulting actual number of players.
_num_players = {}

# Game settings; this is created from games[].settings.
# Keys are the same as the keys in games.
_settings = {}
# }}}

# Translations are done in the browser. This allows marking strings as translatable.
_ = lambda x: x

# Shared object handling. {{{
'''The Shared_Object, Shared_Instance and Shared_Array behave as javascript
objects, objects and arrays respectively. Additionally, any changes made to
them are synchronized over the network with any clients that are supposed to
receive them (depending of whether they are part of Public or Private).
'''
def is_shared(obj):
	return isinstance(obj, (Shared_Object, Shared_Instance, Shared_Array))

class Shared_Object(collections.abc.MutableMapping): # {{{
	def __init__(self, path, target, group):
		self.__dict__['_path'] = path
		self.__dict__['_target'] = target
		self.__dict__['_group'] = group
		self.__dict__['_members'] = {}
		self.__dict__['_alive'] = False
		self.__dict__['_block_send'] = False
	def _setup(self, path, target, group):
		self.__dict__['_path'] = path
		self.__dict__['_target'] = target
		self.__dict__['_group'] = group
	def __setattr__(self, key, value):
		if key in self._members and is_shared(self._members[key]):
			self._members[key]._die()
		self._members[key] = make_shared(self._path, self._target, key, value, send = self._alive and not self._block_send, group = self._group)
	def __getattr__(self, key):
		return self._members[key]
	def __delattr__(self, key):
		if key in self._members and is_shared(self._members[key]):
			self._members[key]._die()
		del self._members[key]
		if self._alive:
			path = self._path[1:] + [key]
			if self._target is None:
				assert self._path[0] == 'Public'
				server.broadcast[self._group].webgame('Public_update', path)
			elif self._path[0] == 'Public':
				assert self._group in self._target.connection._socket.groups
				if self._target.connection:
					self._target.connection._socket.webgame.event('Public_update', path)
			else:
				if self._target.connection:
					self._target.connection._socket.webgame.event('Private_update', path)
	def __getitem__(self, key):
		return getattr(self, str(key))
	def __setitem__(self, key, value):
		return setattr(self, str(key), value)
	def __delitem__(self, key):
		return delattr(self, str(key))
	def __len__(self):
		return len(self._members)
	def __iter__(self):
		yield from iter(self._members)
	def _live(self):
		self.__dict__['_block_send'] = True
		self.__dict__['_alive'] = True
		for i in self._members:
			# Set every item to its value, so the path is set up.
			setattr(self, i, self._members[i])
			if is_shared(self._members[i]):
				self._members[i]._live()
		self.__dict__['_block_send'] = False
	def _die(self):
		self.__dict__['_alive'] = False
		for i in self._members:
			if is_shared(self._members[i]):
				self._members[i]._die()
	def _json(self):
		ret = {}
		for k, v in self._members.items():
			if is_shared(v):
				ret[k] = v._json()
			else:
				ret[k] = v
		return ret
	def __str__(self):
		return '<shared ' + str(dict(self)) + ' >'
# }}}

class Shared_Instance(collections.abc.MutableMapping): # {{{
	def _setup(self, path, target, group):
		self.__dict__['_alive'] = False
		self.__dict__['_path'] = path
		self.__dict__['_target'] = target
		self.__dict__['_group'] = group
		self.__dict__['_block_send'] = False
	def __setattr__(self, key, value):
		if hasattr(self, key):
			old = getattr(self, key)
			if is_shared(old):
				old._die()
		if key.startswith('_'):
			self.__dict__[key] = value
		else:
			self.__dict__[key] = make_shared(getattr(self, '_path', []), getattr(self, '_target', None), key, value, send = getattr(self, '_alive', not getattr(self, '_block_send', True)), group = getattr(self, '_group', None))
	def __delattr__(self, key):
		old = getattr(self, key)
		if is_shared(old):
			old._die()
		delattr(super(), key)
		if hasattr(self, '_alive') and self._alive:
			path = self._path[1:] + [key]
			if self._target is None:
				assert self._path[0] == 'Public'
				server.broadcast[self._group].webgame('Public_update', path)
			elif self._path[0] == 'Public':
				assert self._group in self._target.connection._socket.groups
				if self._target.connection:
					self._target.connection._socket.webgame.event('Public_update', path)
			else:
				if self._target.connection:
					self._target.connection._socket.webgame.event('Private_update', path)
	def __getitem__(self, key):
		return getattr(self, str(key))
	def __setitem__(self, key, value):
		return setattr(self, str(key), value)
	def __delitem__(self, key):
		return delattr(self, str(key))
	def __iter__(self):
		for attr in dir(self):
			if attr.startswith('_'):
				continue
			prop = getattr(self, attr)
			if not is_shared(prop) and not isinstance(prop, (str, bytes, int, float, bool, type(None))):
				continue
			yield attr
	def __len__(self):
		return sum(1 for i in self)
	def _live(self):
		assert not getattr(self, '_alive', False)
		self.__dict__['_block_send'] = True
		self.__dict__['_alive'] = True
		for i in self:
			# Set every item to its value, so the path is set up.
			obj = getattr(self, i)
			setattr(self, i, obj)
			obj = getattr(self, i)
			if is_shared(obj):
				obj._live()
		self.__dict__['_block_send'] = False
	def _die(self):
		self.__dict__['_alive'] = False
		for i in self:
			obj = getattr(self, i)
			if is_shared(obj):
				obj._die()
	def _json(self):
		ret = {}
		for k in self:
			v = getattr(self, k)
			if is_shared(v):
				ret[k] = v._json()
			else:
				ret[k] = v
		return ret
	def __str__(self):
		return '<shared instance ' + str(self._json()) + ' >'
# }}}

class Shared_Array(collections.abc.MutableSequence): # {{{
	def _setup(self, path, target, group):
		self.path = path
		self.target = target
		self.group = group
	def __init__(self, path, target, group):
		self.path = path
		self.target = target
		self.group = group
		self.data = []
		self.alive = False
		self.block_send = False
	def __setitem__(self, index, value):
		if index < 0:
			index += len(self.data)
		assert 0 <= index < len(self.data)
		if is_shared(self.data[index]):
			self.data[index]._die()
		self.data[index] = make_shared(self.path, self.target, index, value, send = self.alive and not self.block_send, group = self.group)
	def __getitem__(self, index):
		return self.data[index]
	def __delitem__(self, index):
		if index < 0:
			index += len(self.data)
		assert 0 <= index < len(self.data)
		if is_shared(self.data[index]):
			self.data[index]._die()
		for i in range(index, len(self.data) - 1):
			self[i] = make_shared(self.path, self.target, i, self[i + 1], send = self.alive and not self.block_send, group = self.group)
		self.data.pop()
		if self.alive:
			path = self.path[1:] + ['length']
			if self.target is None:
				assert self.path[0] == 'Public'
				server.broadcast[self.group].webgame('Public_update', path, len(self.data))
			elif self.path[0] == 'Public':
				assert self.group in self.target.connection._socket.groups
				if self.target.connection:
					self.target.connection._socket.webgame.event('Public_update', path, len(self.data))
			else:
				if self.target.connection:
					self.target.connection._socket.webgame.event('Private_update', path, len(self.data))
	def __lt__(self, other):
		return list(self) < list(other)
	def __eq__(self, other):
		if not isinstance(other, (list, Shared_Array)):
			return False
		return list(self) == list(other)
	def __len__(self):
		return len(self.data)
	def insert(self, index, obj):
		if index < 0:
			index += len(self.data)
		assert 0 <= index <= len(self.data)
		if index < len(self.data):
			self.data.append(make_shared(self.path, self.target, len(self.data), self.data[-1], send = False, group = self.group))
			for i in range(len(self.data) - 2, index, -1):
				if is_shared(self.data[i]):
					self.data[i]._die()
				self.data[i] = make_shared(self.path, self.target, i, self[i - 1], send = False, group = self.group)
			self.data[index] = make_shared(self.path, self.target, index, obj, send = False, group = self.group)
			if self.target is None or self.target.connection is not None:
				broadcast_shared(self.target, self.path, self)
		else:
			self.data.append(make_shared(self.path, self.target, index, obj, send = self.alive and not self.block_send, group = self.group))
	def _live(self):
		self.block_send = True
		self.alive = True
		for num, i in enumerate(self.data):
			# Set every item to its value, so the path is set up.
			self[num] = i
			if is_shared(i):
				i._live()
		self.block_send = False
	def _die(self):
		self.alive = False
		for i in self.data:
			if is_shared(i):
				i._die()
	def _json(self):
		ret = []
		for v in self.data:
			if is_shared(v):
				ret.append(v._json())
			else:
				ret.append(v)
		return ret
	def __str__(self):
		return '<shared ' + str(list(self)) + ' >'
# }}}

def make_shared(parent_path, target, key, value, send, group): # {{{
	path = parent_path.copy()
	path.append(key)
	if is_shared(value):
		value._setup(path, target, group)
		newvalue = value
		if send:
			newvalue._live()
			if target is None or target.connection is not None:
				broadcast_shared(target and target.connection, path, newvalue, group)
	elif isinstance(value, (tuple, list)):
		newvalue = Shared_Array(path, target, group)
		for i, x in enumerate(value):
			newvalue.append(make_shared(path, target, i, x, False, group))
		if send:
			newvalue._live()
			if target is None or target.connection is not None:
				broadcast_shared(target and target.connection, path, newvalue, group)
	elif isinstance(value, dict):
		newvalue = Shared_Object(path, target, group)
		for i in value:
			newvalue[i] = make_shared(path, target, i, value[i], False, group)
		if send:
			newvalue._live()
			if target is None or target.connection is not None:
				broadcast_shared(target and target.connection, path, newvalue, group)
	elif isinstance(value, (str, bytes, int, float, bool, type(None))):
		newvalue = value
		if send:
			if target is None or target.connection is not None:
				broadcast_shared(target and target.connection, path, newvalue, group)
	else:
		raise AssertionError('item {0} (type {1}) cannot be shared'.format(value, type(value)))
	return newvalue
# }}}

def broadcast_shared(target, path, value, group = None): # {{{
	if isinstance(value, Shared_Object):
		assert group is None or group is value._group
		group = value._group
		value = value._json()
	elif isinstance(value, Shared_Array):
		assert group is None or group is value.group
		group = value.group
		value = value._json()
	if target is None:
		assert group is not None
		assert path[0] == 'Public'
		# Send public update to everyone.
		#log('broadcast {0} {1}'.format(repr(path), repr(value)))
		server.broadcast[group].webgame('Public_update', path[1:], value)
	else:
		if path[0] == 'Public':
			assert group in target._socket.groups
			#log('Public {0} {1}'.format(repr(path), repr(value)))
			# Send public information to target.
			target._socket.webgame.event('Public_update', path[1:], value)
		else:
			#log('Private {0} {1}'.format(repr(path), repr(value)))
			# Send private information for target that is controlling the correct player.
			target._socket.webgame.event('Private_update', path[1:], value)
# }}}
# }}}

# Read info for all games. {{{
gamedirs = set(os.path.realpath(x) for x in fhs.read_data('games', dir = True, multiple = True))
log('game dirs: %s' % repr(gamedirs))
files = []
for d in gamedirs:
	for f in os.listdir(d):
		#log('checking %s' % f)
		name = os.path.join(d, f)
		if not os.path.exists(os.path.join(name, f + os.extsep + 'py')) or not os.path.exists(os.path.join(name, 'html')):
			continue
		log('Found game: %s' % name)
		files.append((name, f))
files.sort();
games = {}
for gamedir in files:
	name = gamedir[1]
	sys.path.insert(0, gamedir[0])
	games[name] = importlib.import_module(name)
	sys.path.pop(0)
	# Set up some globals.
	games[name].transaction = transaction
	games[name].log = websocketd.log
	games[name]._ = _
	games[name].Shared = Shared_Instance
	assert hasattr(games[name], 'num_players')
	if isinstance(games[name].num_players, int):
		_num_players[name] = (lambda name: (lambda x: games[name].num_players))(name)
	elif isinstance(games[name].num_players, (tuple, list)):
		_num_players[name] = (lambda name: (lambda x: x['num_players'] if x['num_players'] in games[name].num_players else games[name].num_players[0]))(name)
	else:
		_num_players[name] = games[name].num_players
	# Set up settings.
	if not hasattr(games[name], 'settings'):
		_settings[name] = {'settings': []}
	else:
		# The game provides its own settings; use them as defaults, then add settings based on files.
		_settings[name] = {'settings': games[name].settings[:]}
	# Build lists of loaded files. {{{
	# These variables all have a 2-D and a 3-D element.
	loader = [[], []]
	can = [False, False]
	targets = [[], []]
	jssrc = os.path.join(gamedir[0], 'html') # Place where web content can be found by this program.

	# Search through directories for all files and sort them into correct data element.
	result = {}
	have_3d = {False: False, True: False}
	for base in ('img', 'jta', 'gani', 'audio', 'text'):
		queue = [
			{'name': (), 'dirname': base, 'pathname': base, 'use-3d': None},
			{'name': (), 'dirname': base + '-2d', 'pathname': base + '-2d', 'use-3d': False},
			{'name': (), 'dirname': base + '-3d', 'pathname': base + '-3d', 'use-3d': True},
		]
		result[base] = {}
		while len(queue) > 0:
			q = queue.pop(0)
			dirname = os.path.join(jssrc, q['dirname'])
			log('game: %s; q: %s; dirname: %s' % (name, q, dirname))
			if not os.path.isdir(dirname):
				continue
			files = [f for f in os.listdir(dirname) if os.path.splitext(f)[1] not in fhs.get_config()['forbidden-exts']]
			for required_suffix, forbidden_suffix, use_3d in (('', ('-2d', '-3d'), None), ('-2d', (), True), ('-3d', (), False)):
				for f in files:
					if not os.path.splitext(f)[0].endswith(required_suffix):
						# Wrong suffix for this loop iteration.
						continue
					if any(os.path.splitext(f)[0].endswith(x) for x in forbidden_suffix):
						# Wrong suffix for this loop iteration.
						continue
					filename = os.path.join(jssrc, f)
					if all(x in (True, False) for x in (use_3d, q['use-3d'])) and (use_3d ^ q['use-3d']):
						# Mix of -3d and -2d suffixes in path can never match anything.
						log('Warning: File ' + filename + ' ignored, because it contains both -2d and -3d parts')
						continue
					base_f = os.path.splitext(f)[0]
					pathname = q['pathname'] + '/' + f
					objname = q['name'] + (base_f[0:len(base_f) - len(required_suffix)],)
					log('f %s objname %s base %s suf %s' % (f, objname, base_f, required_suffix))
					new_use_3d = q['use-3d'] if use_3d is None else use_3d
					# Mark have_3d early, so an empty directory can be used to force a use-3d value.
					if new_use_3d is not None:
						have_3d[new_use_3d] = True
					if os.path.isdir(filename):
						# Add directories to the queue.
						queue.append({'name': objname, 'dirname': filename, 'pathname': pathname, 'use-3d': new_use_3d})
						continue
					# This is a usable file. Add it to the result.
					if objname not in result[base]:
						result[base][objname] = [None, None]
					if new_use_3d is None:
						# No suffix. Fill both fields, only if they are None.
						for i in range(2):
							if result[base][objname][i] is not None:
								log('Warning: file ' + filename + ' exists with -*d suffix and also without it')
								continue
							result[base][objname][i] = {'filename': filename, 'pathname': pathname, 'use-3d': new_use_3d}
						continue
					# new_use_3d is True or False; replace appropriate element.
					result[base][objname][int(new_use_3d)] = {'filename': filename, 'pathname': pathname, 'use-3d': new_use_3d}
	log(result)
	loader = {False: [], True: []}
	for base in result:
		for objname in result[base]:
			for t in (False, True):
				p = result[base][objname][t]
				if p is not None:
					loader[t].append({'type': base, 'object': objname, 'path': p['pathname']})

	if not any(have_3d) or all(have_3d):
		use3d = None
	elif have_3d[False]:
		use3d = False
	else:
		use3d = True


	js = [x for x in os.listdir(jssrc) if x.endswith(os.extsep + 'js') and not os.path.isdir(os.path.join(jssrc, x))]
	css = [x for x in os.listdir(jssrc) if x.endswith(os.extsep + 'css') and not os.path.isdir(os.path.join(jssrc, x))]
	languages = []
	scripts = ['games/{}/{}'.format(name, f) for f in js] + ['games/{}/lang/{}.js'.format(name, lang) for lang in languages]
	scripts.sort()
	styles = ['games/{}/{}'.format(name, f) for f in css]
	styles.sort()
	# }}}

	_settings[name]['name'] = name if not hasattr(games[name], 'name') else games[name].name
	_settings[name]['load3d'] = loader[True]
	_settings[name]['load2d'] = loader[False]
	_settings[name]['use_3d'] = use3d
	_settings[name]['script'] = scripts
	_settings[name]['style'] = styles
	if not any(s['key'] == 'name' for s in _settings[name]['settings']):
		_settings[name]['settings'].insert(0, {'key': 'name', 'type': 'string', 'name': _('Game Name')})
	if isinstance(games[name].num_players, (tuple, list)) and not any(s['key'] == 'num_players' for s in _settings[name]['settings']):
		if _settings[name]['settings'][0]['key'] == 'name':
			p = 1
		else:
			p = 0
		if len(games[name].num_players) <= 5:
			_settings[name]['settings'].insert(p, {'key': 'num_players', 'type': 'radio', 'options': games[name].num_players, 'name': _('Number of Players')})
		else:
			_settings[name]['settings'].insert(p, {'key': 'num_players', 'type': 'select', 'options': games[name].num_players, 'name': _('Number of Players')})
# }}}

server = None

class Player: # Class for player objects. {{{
	'''This class is used for player objects.
	All its attributes are set up and managed by the system, so it does not need any definitions here.
	'''
	def send(self, cmd, *args, **kwargs):
		'''Send an event to the player's connection, if it has one.'''
		if self.connection is None:
			return
		getattr(self.connection._socket, cmd).event(*args, **kwargs)
# }}}

class Task: # Class for parallel tasks. {{{
	'''A task is a coroutine that can run until it yields.
	The yield argument will define when it is resumed.
	It can be a timeout or an input event.
	See details in Instance.run(), or the system documentation.
	'''
	def __init__(self, instance, generator, name):
		self.instance = instance
		self.generator = generator
		self.running = False
		self.name = name
		self.waiters = []
		self.done = False
		self.value = None
		self.idle_pending = None
		self.queue_pending = []
	def stop(self):
		assert not self.running
		self.instance.cleanup(self)
		self.instance.tasks.remove(self)

def schedule(task, arg, check = None, wake = None):
	'''Schedule an instance to run a task with argument.
	If another call is already scheduled, drop this one.'''
	if task.idle_pending is not None:
		return False
	def run():
		task.idle_pending = None
		task.instance.run(task, arg, check, wake)
	task.idle_pending = websocketd.add_idle(run)
	return True

def queue(task, arg, check, wake):
	'''Schedule an instance to run a task with argument.
	If another call is already scheduled, queue this one for later.'''
	if schedule(task, arg, check, wake):
		return
	task.queue_pending.append((arg, check, wake))
# }}}

class Instance: # Class for game instances. {{{
	'''Class for a single game instance.
	This class handles a running game.
	It contains one object of the game.Game class, which is defined in the game file.
	'''
	def __init__(self, gametype, settings, *args):
		'''Set up the instance.
		Initialize the Game object.
		Add players.
		Set up shared objects.
		args is not used; it is present to not crash on invalid input.
		'''
		assert isinstance(settings, dict)
		assert all(isinstance(x, str) for x in settings)
		assert 'name' in settings
		assert gametype == '' or gametype in games
		self.gametype = gametype
		self.timeouts = {}
		self.tasks = []
		self.game = Title() if gametype == '' else games[gametype].Game()
		self.game.launch = self.launch
		self.game.stop_all_tasks = self.stop_all_tasks
		self.game.pause = self.pause
		name = settings['name']
		n = name
		i = 0
		while name in instances:
			name = '{0} ({1})'.format(n, i)
			i += 1
		instances[name] = self
		self.game.settings = settings
		self.game.broadcast = server.broadcast[name]
		self.game.add_player = lambda: self.add_player(False)
		self.game.remove_player = self.remove_player
		# Allowed commands at this time.  Keys are command names, values are tuples of
		# (function to call or int or sequence of ints) and (generator to resume, or None).
		# Ints are players that are allowed to use this command.
		self.cmds = {}
		self.ended = False
		# Initialize Public variables.
		self.game.Public = Shared_Object(['Public'], None, name)
		self.game.Public._live()
		self.game.Public.name = name
		self.game.Public.type = gametype
		self.game.Public.players = []
		self.game.Public.viewers = []
		# Set up players.
		if name != '':
			# Figure out number of players.
			num_players = _num_players[gametype](settings)
			title_game.game.Public.games[name] = [None] * num_players
		else:
			num_players = 0
		self.game.players = []
		for p in range(num_players):
			self.add_player(True)
		# Start game.
		self.launch(self.game.run(), 'main', run_now = True)
		log("started new instance of {0}: '{1}'".format(gametype, name))

	def close(self):
		'''Stop instance. All tasks are aborted.'''
		if self.game.Public.name not in instances:
			# Already closed.
			return
		log("stopped instance '{0}'".format(self.game.Public.name))
		del instances[self.game.Public.name]
		self.stop_all_tasks()
		for c in connections:
			if connections[c]._instance != self:
				continue
			admin({'connection': connections[c], 'args': ['leave']})
		self.game.Public._die()
		for p in self.game.players:
			p.Private._die()
		if self is not title_game:
			del title_game.game.Public.games[self.game.Public.name]

	def end_game(self, code):
		'''End a game. The instance is not stopped until all connections to it have left.
		This function is called when there are no more running tasks.'''
		#log('done')
		self.ended = True
		self.game.Public.ended = True
		self.game.broadcast.webgame('end', code)
		if all(p.connection is None for p in self.game.players):
			self.close()

	def run(self, task, arg, check, wake):
		'''Run a task of this instance.
		This is called when a task is launched, and when it is resumed for any reason.
		when it is launched, arg is None.
		when it is resumed from a timeout, arg is None.
		when it is resumed because a task that was waited for has finished, arg is the return value.
		when it is resumed because a client made a call, arg is an args dict as defined in Connection.__getattr__.wrap().
		'''
		if check is not None:
			canrun = check(task)
			if canrun is not True:
				while len(task.queue_pending) > 0:
					arg, check, wake = task.queue_pending.pop(0)
					if check(task) is True:
						break
				else:
					return
			task.reply = wake
		self.cleanup(task)
		if len(task.queue_pending) > 0:
			schedule(task, *task.queue_pending.pop(0))
		self.game.now = time.time()
		end_task = (False, None)
		def reply(*ret):
			assert task.reply is not None
			assert len(ret) > 0
			task.reply(ret[0] if len(ret) == 1 else ret)
			task.reply = None
		self.game.reply = reply
		transaction.enter(self)
		task.running = True
		try:
			#log('sending {0}'.format(repr(arg)))
			cmd = task.generator.send(arg)
		except StopIteration as e:
			task.value = e.value
			task.done = True
			end_task = (True, e.value)
		task.running = False
		transaction.leave(self)
		del self.game.reply
		if hasattr(task, 'reply'):
			if task.reply is not None:
				task.reply(None)
			del task.reply
		#log('cmd = {0}'.format(repr(cmd)))
		if end_task[0] or cmd is None:
			for t in task.waiters:
				# task died and t wants to know. schedule notification.
				schedule(t, end_task[1])
			self.tasks.remove(task)
			if len(self.tasks) == 0:
				self.end_game(end_task[1])
			return
		# Convert cmd to dict if it isn't.
		if not isinstance(cmd, (tuple, list, set, frozenset, dict)):
			cmd = (cmd,)
		if isinstance(cmd, (tuple, list, set, frozenset)):
			def mkcmd(src):
				for c in src:
					if isinstance(c, (int, float)):
						yield (None, c)
					else:
						yield (c, None)
			cmd = {x: y for x, y in mkcmd(cmd)}
		#log('new cmd: {0}'.format(repr(cmd)))
		# Check if we're waiting for a task that is already finished.
		for c in cmd:
			if isinstance(c, Task) and c.done:
				# task died earlier but t still wants to know. schedule notification.
				schedule(task, c.value)
				return
		# Schedule new timeout.
		if None in cmd:
			t = cmd.pop(None)
			# If t is less than a year after the epoch, use it as a timeout from now. Otherwise use it as absolute time.
			if t < 3600 * 24 * 365.25:
				t += self.game.now
			self.timeouts[task] = websocketd.add_timeout(t, lambda: self.timeouts.pop(task) and self.run(task, None, None, None))
		# Add waiters to tasks.
		for c in cmd:
			if not isinstance(c, Task):
				continue
			c.waiters.append(task)
		# Add new commands.
		# Insert all actions in one operations, to avoid sending messages that are already outdated.
		prepare_actions = {}
		for c in cmd:	# c is the name of the command, or (name, argdecl).
			if isinstance(c, Task):
				continue
			if isinstance(c, (list, tuple)):
				assert len(c) == 2
				argdecl = c[1]
				cmdname = c[0]
			else:
				argdecl = None
				cmdname = c
			if cmdname in self.cmds:
				assert task not in self.cmds[cmdname]
			else:
				self.cmds[cmdname] = {}
			pcmd = self.parse_args(argdecl, cmd[c])
			self.cmds[cmdname][task] = pcmd
			who = tuple(range(len(self.game.players))) if pcmd[0] is None else pcmd[0]
			for p in who:
				if p not in prepare_actions:
					prepare_actions[p] = {a: True for a in self.game.players[p].Private.actions}
				if cmdname in prepare_actions[p]:
					log('Error: action %s is already allowed for player %s (yield arg: %s)' % (cmdname, p, cmd))
				prepare_actions[p][cmdname] = True
		for p in prepare_actions:
			self.game.players[p].Private.actions = prepare_actions[p]

	def cleanup(self, task):
		'''Remove task and clean up everything.
		This happens any time a task is resumed.
		Things are set back up when it yields.
		Pending calls remain pending.
		Example value for self.cmds: {'play': {task: [0, [int, bool]]}} (player 0 may use the play(int, bool) command, registered by task)
		'''
		prepare_actions = {}
		for k in [x for x in self.cmds if task in self.cmds[x]]:
			who = tuple(range(len(self.game.players))) if self.cmds[k][task][0] is None else self.cmds[k][task][0]
			for p in who:
				if not isinstance(p, Task):
					if p not in prepare_actions:
						prepare_actions[p] = {a: True for a in self.game.players[p].Private.actions if a}
					#log(repr((prepare_actions[p], k, self.game.players[p].Private.actions)))
					del prepare_actions[p][k]
			del self.cmds[k][task]
		for p in prepare_actions:
			self.game.players[p].Private.actions = prepare_actions[p]
		if task in self.timeouts:
			websocketd.remove_timeout(self.timeouts.pop(task))
		if task.idle_pending is not None:
			websocketd.remove_idle(task.idle_pending)
			task.idle_pending = None
		for t in [x for x in self.tasks if task in x.waiters]:
			t.remove(task)

	def update_stats(self):
		if self is title_game:
			return
		num = len(self.game.players)
		for p, player in enumerate(self.game.players):
			name = None if player.connection is None else player.connection._name
			public = title_game.game.Public.games[self.game.Public.name]
			while len(public) < num:
				public.append(None)
			if public[p] != name:
				public[p] = name
				self.game.Public.players[p].name = name

	def add_player(self, force):
		'''Add a player to the game.
		This function can be called from the Game class, but then force is set to False and cannot be passed.
		Adding players is allowed or forbidden by the game. Force is used to add initial players.
		'''
		# FIXME: adding players while the game is running is broken.
		p = Player()
		p.connection = None
		p.Private = Shared_Object(['Private'], p, self.game.Public.name)
		p.Private._live()
		p.Private.actions = {}
		#log('appending {0}'.format(p))
		self.game.players.append(p)
		self.game.Public.players.append({'name': None})
		num = len(self.game.players) - 1
		if hasattr(self.game, 'player_added'):
			self.game.player_added(num)
		return num

	def remove_player(self, p):
		'''Remove a player from the game.
		This function is never called by the system. It can only be called from the Game class.
		'''
		# FIXME: removing players while the game is running is broken.
		assert len(self.game.players) > _num_players[self.gametype][0]
		assert p < len(self.game.players)
		if hasattr(self.game, 'player_removed'):
			self.game.player_removed(p)
		if self.game.players[p].connection is not None:
			c = self.game.players[p].connection
			admin({'connection': c, 'args': ['leave']})
		self.game.players[p].Private._die()
		self.game.Public.players.pop(p)
		self.game.players.pop(p)
		self.update_stats()

	def launch(self, f, name = None, run_now = False):
		'''Add and run a new Task for this Instance.
		If run_now is True, it will be started before this function returns.
		Otherwise, it will be registered for starting when idle.
		This function can be called from the Game class.
		'''
		t = Task(self, f, name if name is not None else 'Nameless Task')
		self.tasks.append(t)
		if run_now:
			self.run(t, None, None, None)
		else:
			# schedule initial run of task.
			schedule(t, None)
		return t

	def stop_all_tasks(self):
		for t in self.tasks[:]:
			if t.running:
				#log('not stopping running task %s' % t.name)
				continue
			#log('stopping task %s' % t.name)
			t.stop()

	def pause(self, seconds):
		'''Pause the game until all players have responded or the timeout expired.
		This is a convenience generator which a Task can use with:
		yield from pause(...)'''
		who = list(range(len(self.game.players)))
		if seconds is None:
			timeout = None
		else:
			timeout = time.time() + seconds
		while len(who) > 0:
			if timeout is None:
				r = (yield {'resume': who})
			else:
				r = (yield {'resume': who, None: timeout})
			if r is None:
				break
			who.remove(r['player'])

	def parse_args(self, argdecl, cmd):
		if argdecl is not None:
			translation = {'i': int, 's': str, 'f': float, 'b': bool, '*': None}
			argdecl = tuple(map(lambda x: translation[x], argdecl))
		if cmd is None:
			return (None, argdecl)
		if isinstance(cmd, int):
			return ((cmd,), argdecl)
		assert isinstance(cmd, (list, tuple))
		assert all(isinstance(x, int) for x in cmd)
		return (cmd, argdecl)

	def check_args(self, argdecl, a, ka):
		if argdecl is None:
			return True
		# If the command exists and is valid for this player, but the arguments are wrong, notify player.
		if len(ka) > 0:
			return _('Function $1 called with keyword arguments: $2'), (repr(ka),)
		if len(a) != len(argdecl):
			return _('incorrect number of arguments to function $1 (given $2, expected $3)'), (len(a), len(argdecl))
		if any(decl is not None and not isinstance(arg, decl) for arg, decl in zip(a, argdecl)):
			return _('incorrect argument type given to function $1'), ()
		return True
# }}}

class Args(dict): # Class for command arguments; ordered dict. {{{
	def __init__(self, a, ka):
		for k in ka:
			self[k] = ka[k]
		for i, v in enumerate(a):
			self[i] = v
		self.length = len(a)
	def __len__(self):
		return self.length
	def pop(self, idx = -1):
		if idx < 0:
			idx += self.length
		ret = self[idx]
		for i in range(idx, self.length - 1):
			self[i] = self[i + 1]
		del self[self.length - 1]
		self.length -= 1
		return ret
	def __iter__(self):
		for i in range(self.length):
			yield self[i]
# }}}

class Connection: # {{{
	def _set_name(self, name):
		'''Set a new name for this connection.'''
		if self._name is not None:
			del connections[self._name]
		self._name = name
		i = 0
		while self._name in connections:
			self._name = '{0} {1}'.format(name, i)
			i += 1
		connections[self._name] = self
		self._socket.webgame.event('id', self._name, self._num)
		self._instance.update_stats()
	def __init__(self, socket):
		'''Set up a new connection.
		This is called by the server when it has accepted a new websocket connection.
		'''
		self._socket = socket
		self._instance = title_game
		self._name = None
		self._num = None
		if 'name' in socket.data['query']:
			self._set_name(socket.data['query']['name'][0])
		else:
			self._set_name('Anonymous')
		self._socket.closed = self._closed
		self._socket.groups.add(title_game.game.Public.name)
		# Inform about state.
		accept_languages = self._socket.data.get('accept-language')
		languages = [] if accept_languages is None else [x.split(';')[0].replace('-', '_') for x in accept_language.split(',')]
		language = socket.data['query'].get('language')
		if language is not None:
			if language in languages:
				languages.remove(language)
			languages.insert(0, socket.data['query']['language'])
		self._socket.webgame.event('id', self._name, None)
		self._socket.webgame.event('init', languages, _settings)
		broadcast_shared(self, ['Public'], self._instance.game.Public)
		broadcast_shared(self, ['Private'], None, title_game.game.Public.name)
	def _closed(self):
		'''This is called by the server when the connection has closed.'''
		if self._instance is not title_game:
			admin({'connection': self, 'args': ['leave']})
		del connections[self._name]
	def __getattr__(self, attr):
		'''This defines which commands can be called by the clients.
		It calls registered tasks on their behalf.
		This function can fail if the requested command is not registered by any task.
		If the function cannot be called by this connection, that is detected in the call.
		If a function is called, its return value is passed to the caller.
		If no function is called, None is returned to the caller.'''
		if attr.startswith('_'):
			raise AttributeError('invalid attribute name for getattr')
		if attr in cmds:
			targets = cmds[attr]
			instance = None
		elif self._instance is not None and attr in self._instance.cmds:
			targets = self._instance.cmds[attr]
			instance = self._instance
		else:
			# This may happen due to the asynchronous communication, so it should not produce an error for the user.
			log('attribute not found: {0} not in {1} {2} (ignored)'.format(attr, repr(cmds), repr(self._instance.cmds)))
			return
		def wrap(*a, **ka):
			wake = (yield)
			def check_task(task):
				if attr not in task.instance.cmds or task not in task.instance.cmds[attr]:
					log('wrong attr: %s not in %s + %s' % (attr, repr(task.instance.cmds), None if attr not in task.instance.cmds else repr(task.instance.cmds[attr])))
					return False
				who, funcargs = task.instance.cmds[attr][task]
				if isinstance(who, (tuple, list, set, frozenset)):
					if self._num not in who:
						return False
					who = None
				check = self._instance.check_args(funcargs, a, ka)
				if check is True:
					return True
				# This error should be passed to the player.
				if hasattr(self._instance.game, 'error'):
					return self_instance.game.error(self, check[0], *((attr,) + check[1]))
				return (check[0], attr) + check[1]
			for task in targets.copy(): # Try to run this command on any task, until it is allowed.
				if task is None:
					who, funcargs = cmds[attr][None]
				else:
					who, funcargs = task.instance.cmds[attr][task]
					check = check_task(task)
					if check is False:
						continue
					if check is not True:
						return check
				args = {'args': Args(a, ka), 'connection': self, 'player': self._num, 'command': attr}
				if who is not None and not isinstance(who, (tuple, list, set, frozenset)):
					# Connection has requested to run a function. Schedule it.
					websocketd.add_idle(lambda: wake(who(args)))
				elif task is not None:
					# Connection has requested to wake a task. Schedule it.
					queue(task, args, check_task, wake)
				return (yield)
			# This may happen due to the asynchronous communication, so it should not produce an error for the user.
			log('ignoring invalid command {} from {}'.format(attr, self._name))
			return None
		return wrap
# }}}

class Title: # Class for title game object. {{{
	'''Class for the title game instance.
	The system sets up one title instance and allows starting any number of Game instances.
	'''
	def run(self):
		'''Run the title "game".
		This allows players to set their names, create a game, or join, return to and view a game.
		'''
		self.Public.games = {}
		while True:
			cmd = (yield ('new', 'join', 'return', 'view'))
			connection = cmd['connection']
			command = cmd['command']
			num = connection._num
			#log('received title command {0}'.format(cmd))
			if len(cmd['args']) < 1:
				connection._instance.game.reply(_('no game name specified'))
				continue
			if command == 'new':
				if len(cmd['args']) < 2:
					connection._instance.game.reply(_('no game name specified'))
					continue
				gametype = cmd['args'].pop(0)
				if gametype not in games:
					connection._instance.game.reply(_('game type does not exist'))
					continue
				# Launching the game breaks the transaction logic. Hack around that by breaking the pending transaction in two parts.
				transaction.leave(title_game)
				i = Instance(gametype, *cmd['args'])
				transaction.enter(title_game)
				cmd['args'][0] = i.game.Public.name
				i.game.Public.owner = 0
				command = 'join'	# fall through.
			if not isinstance(cmd['args'][0], str) or cmd['args'][0] not in instances:
				connection._instance.game.reply(_("game doesn't exist"))
				continue
			instance = instances[cmd['args'][0]]
			if command == 'join':
				for i, p in enumerate(instance.game.players):
					if p.connection is None:
						connection._num = i
						break
				else:
					connection._instance.game.reply(_('no more players allowed'))
					continue
				instance.game.Public.players[connection._num].name = connection._name
				instance.game.players[connection._num].connection = connection
				connection._instance = instance
				connection._socket.groups.remove(self.Public.name)
				connection._socket.groups.add(cmd['args'][0])
				connection._socket.webgame.event('id', connection._name, connection._num)
				# Private must be sent before Public, because when Public.name is set, all shared variables must be available.
				broadcast_shared(connection, ['Private'], connection._instance.game.players[connection._num].Private)
				broadcast_shared(connection, ['Public'], connection._instance.game.Public)
				instance.update_stats()
			elif command == 'return':
				if len(cmd['args']) < 2 or cmd['args'][1] >= len(instance.game.players) or instance.game.players[cmd['args'][1]].connection is not None:
					connection._instance.game.reply(_('invalid player number to return to'))
					continue
				connection._instance = instance
				connection._num = cmd['args'][1]
				connection._socket.webgame.event('id', connection._name, connection._num)
				instance.game.players[cmd['args'][1]].connection = connection
				connection._socket.groups.remove(self.Public.name)
				connection._socket.groups.add(cmd['args'][0])
				connection._instance.game.Public.players[connection._num].name = connection._name
				instance.update_stats()
				broadcast_shared(connection, ['Private'], connection._instance.game.players[connection._num].Private)
				broadcast_shared(connection, ['Public'], connection._instance.game.Public)
				instance.update_stats()
			elif command == 'view':
				connection._instance = instance
				connection._socket.groups.remove(self.Public.name)
				connection._socket.groups.add(cmd['args'][0])
				instance.game.Public.viewers.append({'name': connection._name})
				broadcast_shared(connection, ['Public'], connection._instance.game.Public)
				broadcast_shared(connection, ['Private'], None)
				instance.update_stats()
			else:
				connection._instance.game.reply(_('Impossible command'))
				continue
# }}}

def admin(args): # {{{
	'''Function that is registered as a global command, so it is always available.
	It handles the administrative commands: leaving the game, and name change.
	'''
	connection = args['connection']
	cmd = args['args']
	if len(cmd) < 1 or cmd[0] not in ('leave', 'name', 'claim', 'release', 'kick', 'chat', 'swap'):
		return _('invalid admin command')
	if cmd[0] == 'name':
		if len(cmd) < 2:
			name = 'Anonymous'
		else:
			name = cmd[1]
		connection._set_name(name)
	elif cmd[0] == 'leave':
		if connection._instance is title_game:
			return _('Cannot leave from title')
		end = None
		if connection._num is not None:
			if connection._instance.game.Public.owner == connection._num:
				connection._instance.game.Public.owner = None
			connection._instance.game.players[connection._num].connection = None
			connection._instance.game.Public.players[connection._num].name = None
			config = fhs.get_config()
			if (not config['keep'] or connection._instance.ended) and all(p.connection is None for p in connection._instance.game.players):
				# Last player left; destroy game if it was still running.
				end = connection._instance
			else:
				connection._instance.update_stats()
		else:
			idx = [x for x, v in enumerate(connection._instance.game.Public.viewers) if v['name'] == connection._name][0]
			connection._instance.game.Public.viewers.pop(idx)
		connection._socket.groups.remove(connection._instance.game.Public.name)
		connection._instance = title_game
		connection._socket.groups.add(title_game.game.Public.name)
		connection._num = None
		connection._socket.webgame.event('id', connection._name, None)
		broadcast_shared(connection, ['Public'], connection._instance.game.Public)
		broadcast_shared(connection, ['Private'], None, title_game.game.Public.name)
		if end:
			end.close()
	elif cmd[0] == 'claim':
		if connection._num is None:
			return _('Cannot claim ownership without being in a game')
		if connection._instance.game.Public.owner is not None:
			return _('Cannot force ownership release')
		connection._instance.game.Public.owner = connection._num
	elif cmd[0] == 'release':
		if connection._num is None:
			return _('Cannot release ownership without being in a game')
		if connection._instance.game.Public.owner != connection._num:
			return _('Cannot release without ownership')
		connection._instance.game.Public.owner = None
	elif cmd[0] == 'kick':
		if not isinstance(cmd[1], str):
			return _('Kick requires a string argument')
		if connection._num is None:
			return _('Cannot kick players without being in a game')
		if connection._instance.game.Public.owner != connection._num:
			return _('Cannot kick without ownership')
		if cmd[1] == connection._name:
			return _('Cannot kick yourself')
		if cmd[1] not in connections or connections[cmd[1]]._instance != connection._instance:
			return _('That player is not in this game')
		return admin({'connection': connections[cmd[1]], 'args': ['leave']})
	elif cmd[0] == 'chat':
		connection._instance.game.broadcast.webgame('chat', connection._num if connection._num is not None else connection._name, cmd[1])
	elif cmd[0] == 'swap':
		if connection._num is None:
			return _('Watchers cannot swap with players')
		the_game = connection._instance.game
		num = len(the_game.players)
		if len(cmd) < 2 or not isinstance(cmd[1], int) or not 0 <= cmd[1] < num:
			for i in range(1, num):
				p = (connection._num + i) % num
				if the_game.players[p].connection is None:
					dstnum = p
					break
			else:
				return _('There is no disconnected player to swap with')
		else:
			dstnum = cmd[1]
		srcnum = connection._num if len(cmd) < 3 or not isinstance(cmd[2], int) or not 0 <= cmd[2] < num else cmd[2]
		src = the_game.players[srcnum]
		dst = the_game.players[dstnum]
		if (dst.connection is not None or srcnum != connection._num) and the_game.Public.owner != connection._num:
			return _('Cannot swap without ownership (num = %d, owner = %d)' % (connection._num, the_game.Public.owner))
		src_connection = src.connection
		src.connection = dst.connection
		dst.connection = src_connection
		if src.connection is not None:
			src.connection._num = srcnum
		if dst.connection is not None:
			dst.connection._num = dstnum
		# Update user info.
		for target, num in zip((src, dst), (srcnum, dstnum)):
			if target.connection is not None:
				target.connection._socket.webgame.event('id', target.connection._name, num)
				broadcast_shared(target.connection, ['Private'], target.Private)
				the_game.Public.players[num].name = target.connection._name
			else:
				the_game.Public.players[num].name = None
		if srcnum == the_game.Public.owner:
			the_game.Public.owner = dstnum
		elif dstnum == the_game.Public.owner:
			the_game.Public.owner = srcnum
# }}}


def show(obj, indent = '', prefix = ''): # {{{
	if isinstance(obj, (Shared_Array, tuple, list)):
		print(indent + prefix + '[')
		for i, v in enumerate(obj):
			show(v, indent + '  ', '%d: ' % i)
		print(indent + ']')
	elif isinstance(obj, (Shared_Object, Shared_Instance, dict)):
		print(indent + prefix + '{')
		for k in obj:
			show(obj[k], indent + '  ', '%s: ' % k)
		print(indent + '}')
	else:
		print(indent + prefix + repr(obj))
# }}}

def adminjoin(name = None): # {{{
	if name is None:
		if len(instances) < 2:
			name = ''
		else:
			name = tuple(x for x in instances if x != '')[0]
	if name not in instances:
		print('name %s does not exist' % name, file = sys.stderr)
		return
	adminvars['instance'] = instances[name]
	adminvars['game'] = adminvars['instance'].game
	print('Joined "%s"' % name)
adminvars = {'instance': None, 'game': None, 'join': adminjoin}
def stdinput(line):
	try:
		exec(line.replace('###', '\n'), None, adminvars)
	except:
		traceback.print_exc()
# }}}

def Game(): # Main function to start a game. {{{
	'''This function starts the system.
	This function should not be confused with class game[].Game, which defines the rules of the game.
	This starts a title instance and sets up the server.
	webgame-build automatically calls this function after the code in the game file is run.
	'''
	global server, title_game
	# Set up module path.
	sys.path = [os.path.join(os.curdir, 'modules')] + sys.path
	# Set up commands.
	cmds['webgame'] = {None: (admin, None)}
	# Start debug console on stdio.
	global stdio
	stdio = network.wrap(sys.stdin, sys.stderr)
	stdio.readlines(stdinput)
	# Start up websockets server.
	config = fhs.get_config()
	httpdirs = [fhs.read_data(x, opened = False, multiple = True, dir = True) for x in ('html',) + tuple(os.path.join('html', name) for name in games)]
	server = websocketd.RPChttpd(config['port'], Connection, tls = config['tls'], httpdirs = sum(httpdirs, []), proxy = 'game')
	server.handle_ext('png', 'image/png')
	server.handle_ext('svg', 'image/svg+xml')
	server.handle_ext('jpg', 'image/jpeg')
	server.handle_ext('jpeg', 'image/jpeg')
	server.handle_ext('gif', 'image/gif')
	server.handle_ext('gani', 'text/plain')
	server.handle_ext('wav', 'audio/wav')
	server.handle_ext('ogg', 'audio/ogg')
	server.handle_ext('mp3', 'audio/mp3')
	server.handle_ext('jta', 'application/octet-stream')
	server.handle_ext('txt', 'text/plain')
	server.handle_ext('frag', 'text/plain')
	server.handle_ext('vert', 'text/plain')
	server.handle_ext('glsl', 'text/plain')
	# Set up title page.
	title_game = Instance('', {'name': ''})
	# Add the admin to the title game.
	adminjoin()
	log('Game started, listening on port {0}'.format(config['port']))
	# Main loop.
	websocketd.fgloop()
	# End of game.  Do anything to clean up?
# }}}

Game()

# vim: set foldmethod=marker :
