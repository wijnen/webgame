#!/usr/bin/python3

'''Compiler for webgames.  This program does the following: {{{

- Create a directory that contains all files required for running the game.
- Inject code into html and js files to load all assets.
- Add header and footer to main file so it is an executable.
- Run the newly built server.

The result is placed in the location for webgames, $(XDG_DATA_HOME)/webgame by
default.  Under there, the game is placed named game, the assets are
placed in html/game/, and extra python files are placed under
modules/game/.  The generated header in the executable adds that path to
the module search path if it is created.

If modules that are used by the builder are included from the main source
directory, they are copied into the build directory.  network, websocketd and
webgame are imported so this method can be used for them.

<GAMENAME>
modules/game/*.py
html/mgrl.js
html/gl-matrix.js
html/builders.js
html/rpc.js
html/webgame.js
html/webgame.css
html/game/*.js
html/game/index.html
html/game/img/*.png
html/game/jta/*.jta
...
}}}'''

# Imports and config. {{{
import fhs
import network
import websocketd
import webgame
import sys
import os
import shutil
import json
import subprocess

config = fhs.init({'src': '.', 'dest': '', 'link': True, 'name': '', 'base': '', 'run': True}, game = True, packagename = 'python3-webgame')
# }}}

# Find source files. {{{
dest = config['dest'] or fhs.write_data('webgame', dir = True, opened = False)
main = [x for x in os.listdir(config['src']) if os.path.splitext(x)[1] == os.extsep + 'gpy' and not os.path.isdir(os.path.join(config['src'], x))]
if len(main) != 1:
	sys.stderr.write('only one main file allowed; found ' + ', '.join(main) + '\n')
	sys.exit(1)
main = os.path.splitext(main[0])[0]
name = config['name'] or main.capitalize()
webbase = "\t\t<base href='{}'/>".format(config['base']) if config['base'] else ''
modules = [x for x in os.listdir(config['src']) if x.endswith(os.extsep + 'py') and not os.path.isdir(os.path.join(config['src'], x))]
jssrc = os.path.join(config['src'], 'html')
if os.path.isdir(jssrc):
	js = [x for x in os.listdir(jssrc) if x.endswith(os.extsep + 'js') and not os.path.isdir(os.path.join(jssrc, x))]
else:
	websocketd.log('Warning: no html directory found in {}; game will be useless'.format(config['src']))
	js = []
js.sort()
# }}}

# Create destination directory. {{{
if os.path.exists(os.path.join(dest)):
	shutil.rmtree(os.path.join(dest))
os.makedirs(os.path.join(dest, 'html', 'game'))
# }}}

def copy(src, dst): # {{{
	assert src and os.path.exists(src)
	src = os.path.abspath(src)
	dst = os.path.abspath(dst)
	base = os.path.dirname(dst)
	if not os.path.isdir(base):
		os.makedirs(base)
	if config['link']:
		if os.path.exists(dst):
			os.unlink(dst)
		os.symlink(src, dst, os.path.isdir(src))
	else:
		if os.path.exists(dst):
			shutil.deltree(dst)
		shutil.copytree(src, dst)
# }}}

# Write javascript files. {{{
for j in js:
	copy(os.path.join(jssrc, j), os.path.join(dest, 'html', 'game', j))
# }}}

# Write or link python modules.
if len(modules) > 0:
	os.makedirs(os.path.join(dest, 'modules'))
	for m in modules:
		copy(os.path.join(config['src'], m), os.path.join(dest, 'modules', m))

def makeaudio(dirobj, dir): # {{{
	if not os.path.isdir(dir):
		return []
	ret = []
	for f in os.listdir(dir):
		if os.path.splitext(f)[1][len(os.path.extsep):] not in ('wav', 'ogg', 'mp3'):
			continue
		if os.path.isdir(f):
			d = dirobj.copy()
			d.append(f)
			ret.extend(makeaudio(d, os.path.join(dir, f)))
		else:
			ret.append((dirobj, f, os.path.splitext(f)[0]))
	return ret
audio = json.dumps(makeaudio([], os.path.join(jssrc, 'audio')))
# }}}

def find(srcbase, destbase, prefix, antisuffix): # {{{
	if not os.path.exists(srcbase):
		return []
	files = os.listdir(srcbase)
	subdirs = [x for x in files if os.path.isdir(os.path.join(srcbase, x))]
	ret = [(os.path.join(srcbase, x), os.path.join(destbase, x), prefix + '/' + x if len(prefix) > 0 else x) for x in files if not x.startswith('.') and not os.path.isdir(os.path.join(srcbase, x)) and not os.path.splitext(x)[0].endswith(antisuffix)]
	for sd in subdirs:
		ret.extend(find(os.path.join(srcbase, sd), os.path.join(destbase, sd), prefix + '/' + sd if len(prefix) > 0 else sd, antisuffix))
	return ret
# }}}

# Generate javascript load statements. {{{
loader_js = [None, None]
can = [False, False]
targets = [[], []]
for suffix, antisuffix, use_3d in (('-2d', '-3d', False), ('-3d', '-2d', True)):
	for base in ('img', 'jta', 'gani', 'audio', 'text'):
		suffixtargets = find(os.path.join(jssrc, base + suffix), os.path.join(dest, 'html', 'game', base), '', antisuffix)
		can[use_3d] = can[use_3d] or os.path.exists(os.path.join(jssrc, base + suffix))
		targets[use_3d].extend(suffixtargets)
		targets[use_3d].extend(find(os.path.join(jssrc, base), os.path.join(dest, 'html', 'game', base), '', antisuffix))
	if len(targets[use_3d]) > 0:
		can[use_3d] = can[use_3d] or any(os.path.splitext(x[0])[0].endswith(suffix) for x in targets[use_3d])
		loader_js[use_3d] = ["\tplease.load('{}');".format(f[2]) for f in targets[use_3d]]
		loader_js[use_3d].sort()
		loader_js[use_3d] = '\n'.join(loader_js[use_3d])
	else:
		# Nothing to load, but force the "finished loading" event to fire anyway.
		loader_js[use_3d] = '\twindow.dispatchEvent(new CustomEvent("mgrl_media_ready"));'
# }}}

# Generate 3-D detection code. {{{
if not any(can):
	use3d = '''\
	use_3d = true;
	if (document.location.search[0] == '?') {
		var s = document.location.search.substring(1).split('&');
		for (var i = i; i < s.length; ++i) {
			var kv = s[i].split('=', 1);
			if (kv[0] == '2d' && kv[1] != '0') {
				use_3d = false;
				break;
			}
		}
	}'''
	loader_js = '''\
	if (use_3d) {
		%s
	}
	else {
		%s
	}''' % (loader_js[True], loader_js[False])
	for t in targets[False]:
		copy(t[0], t[1])
	for t in targets[True]:
		copy(t[0], t[1])
elif can[False]:
	use3d = '\tuse_3d = false;'
	loader_js = loader_js[True]
	for t in targets[True]:
		copy(t[0], t[1])
with open(os.path.join(dest, 'html', 'webgame' + os.extsep + 'js'), 'w') as f:
	f.write(fhs.read_data(os.path.join('html', 'webgame' + os.extsep + 'js')).read().replace('#LOAD#', loader_js).replace('#AUDIO#', audio).replace('#USE3D#', use3d))
# }}}

# Copy or link system files. {{{
copy(fhs.read_data('rpc' + os.extsep + 'js', packagename = 'python3-websocketd'), os.path.join(dest, 'html', 'rpc' + os.extsep + 'js'))
copy(fhs.read_data(os.path.join('html', 'webgame' + os.extsep + 'css'), opened = False), os.path.join(dest, 'html', 'webgame' + os.extsep + 'css'))
copy(fhs.read_data(os.path.join('html', 'gl-matrix' + os.extsep + 'js'), opened = False), os.path.join(dest, 'html', 'gl-matrix' + os.extsep + 'js'))
copy(fhs.read_data(os.path.join('html', 'mgrl' + os.extsep + 'js'), opened = False), os.path.join(dest, 'html', 'mgrl' + os.extsep + 'js'))
copy(fhs.read_data('builders' + os.extsep + 'js', opened = False, packagename = 'python3-websocketd'), os.path.join(dest, 'html', 'builders' + os.extsep + 'js'))
# }}}

# Create main html file. {{{
index = os.path.join(dest, 'html', 'game', 'index' + os.extsep + 'html')
with open(index, 'w') as f:
	files = ["\t\t<script type='application/javascript' src='webgame.js'></script>"] + ["\t\t<script type='application/javascript' src='game/{}'></script>".format(f) for f in js]
	#print('name: {}\nbase: {}\nsource: {}'.format(name, webbase, files))
	f.write(fhs.read_data(os.path.join('html', 'webgame' + os.extsep + 'html')).read().replace('#NAME#', name).replace('#BASE#', webbase).replace('#SOURCE#', '\n'.join(files)))
# Make it the default page.
copy(index, os.path.join(dest, 'html', 'index' + os.extsep + 'html'))
# }}}

# Write main python file. {{{
with open(os.path.join(dest, main), 'w') as f:
	f.write('#!/usr/bin/python3\n')
	f.write('import sys\n')
	f.write("sys.path = ['{}'] + sys.path\n".format(os.path.join(dest, 'modules')))
	if len(modules) > 0:
		f.write("sys.path = ['{}'] + sys.path\n".format(os.path.join(dest, 'modules')))
	f.write('import webgame\n')
	f.write(open(os.path.join(config['src'], main + os.extsep + 'gpy')).read())
	f.write('\nwebgame.Game()\n')
os.chmod(os.path.join(dest, main), 0o755)
# }}}

# Copy bundled modules. {{{
mydir = os.path.realpath(os.path.dirname(sys.argv[0]))
for m in sys.modules:
	if m == '__main__':
		continue
	if not hasattr(sys.modules[m], '__file__'):
		#print('no file: {}'.format(m))
		continue
	if os.path.realpath(os.path.dirname(sys.modules[m].__file__)) != mydir:
		#print('wrong dir: {} {}'.format(mydir, sys.modules[m].__file__))
		continue
	target = os.path.join(dest, 'modules')
	if not os.path.exists(target):
		os.mkdir(target)
	shutil.copy2(sys.modules[m].__file__, os.path.join(target, os.path.basename(sys.modules[m].__file__)))
# }}}

# Run. {{{
if config['run']:
	subprocess.Popen([os.path.join(dest, main)], close_fds = True).communicate()
# }}}

# vim: set foldmethod=marker :
